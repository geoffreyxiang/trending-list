# General Timeline

## Initial Planning
- Tech Stack: MERN (MongoDB, Express.js, React.js, Node.js)
    - Chose this stack since I was very comfortable with it and I was told that this was the stack used by Snackpass engineers, so it would be easier to understand and ask questions if necessary
- Figma file with low fidelity wireframe for frontend design: https://www.figma.com/file/fegon8lVWH2j6r5pvnmz7A/Snackpass-Challenge?node-id=0%3A1
    - This was the first thing I did (aside from cloning the empty repo)
    - Since I completed the backend first, this Figma file was used more of a reference to guide how I would build my backend database
    - When building frontend, I ultimately opted to save some time by not building out a header or routing system with other pages

## Initial Assumptions
- The app is allowed to refresh on reload instead of live periodic updates when an order turns older than 48 hours old 
    - For live, periodic updates, I would have to use a CronJob
- Certain attributes such as name, price, and restaurant will not change in between orders 
    - If prices do change, I can add 1 line to the '/orders/item' and '/testing/item' PUT endpoints to change the price (specifically adding `currentItem.price = req.body.price` anywhere in the `else` block before  `await currentItem.save()`), which would update the price of the item to match the last order of that item. 
    - However, the current version of my code assumes that customers won't be able to just set the price of their own orders and that restaurants keep their prices relatively stable

## Working on the Codebase
- I first started building out the Schema and routing for the backend (I chose to do backend first since I enjoy doing backend work a lot more, so it was personally easier for me to get started doing this.)
    - Item Schema started off having a name, restaurant_name, price, order_history, and heuristic_value
        - The biggest decision so far was implementing order_history as an array-based Queue that adds newest items to the end and deletes from the beginning (since oldest orders will be deleted first)
        - Although this seemed to be a pretty efficient way to tell if an item has a too-old order (just check the first element), it ended up making testing very painful (Since when I generate random dates, I have to populate the array in order of oldest to newest. Otherwise my program will not be able to detect when an order is too-old. Thus, I had to pre-generate all the dates beforehand when testing.)
    - Routing system was fairly intuitive for me to set up (have an '/items' route to get everything, and have an '/orders' route to simulate customers ordering items)
        - For quick testing purposes, having a way to clear everything from the database and get everything from the database is extremely helpful, so I included those endpoints
        - (I know this is unnecessary but I really wanted to include this) Somewhere along the line, I misspelled 'module.exports' as 'module.export', which took about a half hour to find even though I could tell from the error logs that I had made a spelling mistake somewhere. 
        - I also quickly realized that I should just have a PUT request instead of POST and PUT to handle an order (This just makes it easy to have one endpoint be able to handle everything)
        - The most challenging endpoint to make was the main '/items' GET endpoint since it is the main endpoint that sorts all of the data and then assigns pages to each item so that all the data can be readily put into the frontend. 
            - At the time, I forgot that I was building for an infinite scroll wheel, so I didn't have any pagination features in my backend. The endpoint mentioned simply computed heuristics for each item and then sorted them. 
            - This endpoint also struck me as incredibly inefficient since all of the heuristic-calculating and sorting work is done here. However, since all of the items could have had orders that turned older than 48 hours when refreshing the frontend page (which would call this endpoint), I felt that it was necessary to recompute the heuristic here to account for this possibility. 
            - In hindsight, only new orders should cause a noticeable change in the sorting of items, so some of the pagination and sorting work could have been assigned to the '/order' PUT endpoints
    - After mostly finishing the routing and associated controllers, I created 'randomizedTesting.js' to allow me to create a ton of dummy data to test my backend as well as populate the database with items for my frontend to display (this way, I can continuously test my frontend to see if it's rendering the appropriate backend data as I'm building out each component)
        - In a past internship (when I worked on a Java and PostreSQL backend), I learned that I could use Flyway, which offers a free tool for database migration, which essentially allows you to prepopulate a database with SQL commands in a separate file. However, upon further research, I found that it was generally only really compatible with relational databases (it primarily focused on PostreSQL) and Java. There also didn't seem to be any equivalents for MongoDB and JavaScript. 
- I then transitioned to the frontend, where I already knew I wanted to have some sort of Scroll componenent as well as an Item and Tag component. 
    - I first created a placeholder element for the Item component (it just displayed item.name) so that I could start making my Scroll (this way, I could see if my Scroll component was working if item names were appearing)
        - Here, I realized that I forgot to use CORS in my backend server, which caused my requests from the frontend to be blocked by a security feature that prevents attacks from different domain addresses. This was quickly fixed by installing CORS and using it in my backend. 
    - As I started to work on the infinite-scroll feature, I realized that I would need a separate React hook to check when the last element of a list was displayed as well as call the backend API to get more items to display. This hook ended up being 'useScroll.js'
        - I also realized here that my backend needed to have some sort of pagination process (before, it would just send over the entire array of items, which made implementing an infinite scroll impossible). 
        - This feature ended up being the biggest challenge for me to implement since my program kept having trouble detecting when the last element was displayed and then calling the necessary endpoint once it was detected. Honestly, I had to keep just adjusting the code and using lot of console.log statements to debug before it just ended up working. 
    - After completing the Scroll component, I worked on the Item and Tag components. 
        - These were much easier since they were simply displaying themselves rather than having special hooks and features. 
        - At this point, I wanted to use Tachyons (a CSS framework that I like to use that expedites the process of using CSS), but upon importing the stylesheet, my Scroll component would just stop working, so I ended up just making my own stylesheets for everything. 
    - At this point, I was ready to start testing my program more rigorously, so I created edge case tests and a main test that populated the database with many random orders with random dates.
        - The edge case where an item has only 1 order and that order 'expires' made me realize I didn't delete that item from the database (instead it was maintained and kept in the frontend when it should be kicked out of the Trending list)
        - I solved this by creating a DELETE endpoint within the '/items' route that gets called when a given item's quantity becomes 0. I remember finding out that axios's DELETE request's second parameter is not identical to the PUT and POST request's second parameter, which caused quite a lot of confusion when the item seemed to be getting deleted from the sorted database but was still being displayed in the frontend (it was being removed from the sorted GET response but not being removed from the database)
    - The last bit I had to do was figure out a good heuristic. I initially wanted to account for the span of items being selected (my heuristic included [quantity] / [time at first order - time at last order]), but there was quite a bit of cognitive dissonance when seeing the tags and then seeing what the rankings were (since an item ordered 3 times within the span of 2 minutes would be ranked higher than an item ordered 200 times in the span of 6 hours, but the tags don't show span and rather the 'last ordered')
        - I then decided to just use the 'last ordered' and 'time' Tag values so that any one looking at the list can see some logical connection between trending items. I wanted to have item quantity have a slightly greater weight than the last-ordered value since I figured it was all being ordered in a span of 48 hours anyway. 
        - I finally settled on taking the [quantity] and adding it to a [constant] divided by [the difference in minutes between the last order and Date.now()]. This way, quantity was prioritized, but having a more recent date would have a deciding impact on items that are similar in quantity but vastly different in most recent order. 
        - However, the use of division made a huge impact on items that were ordered very recently (ex. dividing by 2 gives a much greater number than dividing by 5, even though 2 minutes isn't much more than 5 minutes), so I made it so that the value that ended up being divided was rounded up to the nearest 20. This makes it so that any items ordered within 20 minutes of each other would be equally impacted by how long ago they were ordered, and thus would simply be distinguished by quantity. 
- After I finished, I worked on the setup doc and the timeline doc (this!). 

## Reflection
- I thought that I used a lot of what I knew about full stack development in order to complete this project, and I learned a few things in the meantime, especially about syntax when using certain packages. 
- I tried to abide by best practices in my file structure and things such as snake_case vs camelCase in naming conventions. However, since I'm still learning a lot about these things, I'm not 100% sure if I followed all the best principles (I would appreciate knowing if I violating anything in particular)
- The process of debugging added a ton of time to my work, so I'd estimate that in total, I spent around 15 hours on this project. 
    - I am also much stronger and experienced at backend work than frontend, so more time was dedicated to the frontend (especially debugging). I found that when my program was erroring, I was usually much better at figuring out the cause of the bug when it came to backend than frontend. 
- Looking back on my work, there are definitely improvements I can make (though right now I'm more focused on turning in a working project):
    - The main GET endpoint I use to retrieve and sort all the backend data seems to do far too much work, which causes the frontend to sometimes not load any items on large inputs until it is refreshed a few times (I mention this above)
        - Since some of my backend endpoints were built as a 'reaction' to discovered obstacles rather than a 'plan' that accounted for those obstacles, many of them feel a bit haphazard, especially when I call another endpoint in the middle of executing a request. As such, my endpoints can be restructured and rewritten to be cleaner and more effective. For example, I could use a mapper function instead of another endpoint when placing an order and querying an '/order/item' PUT endpoint many times. 
    - My handling of Date objects across the entire codebase is inconsistent. I ran into a few issues when subtracting Date objects (Sometimes they convert into integers and sometimes they don't. The 'Date.getTime()' function also seems to no longer work on the current version of JS), leading me to address them differently on a case-by-case basis.
    - I generally shouldn't settle with a component that I'm afraid could break at any moment. Since importing the Tachyons framework inexplicably broke my Scroll component (which I had spent so long debugging on), I was quite afraid of using anything that would inadvertently cause that component to break. My code could definitely use a CSS framework to make updating its look and adding components easier, though I believe my current stylesheets do a good job of presenting a fairly clean web app. 
    - The heuristic is... okay. Based on my testing, it does a fairly good job of prioritizing quantity and recency accordingly, but it definitely has some holes that cause some items to be ranked higher than they should be. For the sake of time (since I implemented the heuristic-calculating function near the end), I hard-coded a case where if the quantity was less than 10, the heuristic_value would be computed differently and much more harshly. Ideally instead of 10, I would want that value to be somewhere between the first quartile and the median (further testing would help me determine this). To track statistics or metadata about the items, however, I believe it would be best implemented using a separate Schema. 